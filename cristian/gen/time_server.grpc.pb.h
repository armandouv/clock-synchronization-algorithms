// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: time_server.proto
#ifndef GRPC_time_5fserver_2eproto__INCLUDED
#define GRPC_time_5fserver_2eproto__INCLUDED

#include "time_server.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

class TimeServer final {
public:
    static constexpr char const *service_full_name() {
        return "TimeServer";
    }

    class StubInterface {
    public:
        virtual ~StubInterface() {}

        virtual ::grpc::Status
        GetTime(::grpc::ClientContext *context, const ::GetTimeRequest &request, ::Timespec *response) = 0;

        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::Timespec>>
        AsyncGetTime(::grpc::ClientContext *context, const ::GetTimeRequest &request, ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::Timespec>>(
                    AsyncGetTimeRaw(context, request, cq));
        }

        std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::Timespec>>
        PrepareAsyncGetTime(::grpc::ClientContext *context, const ::GetTimeRequest &request,
                            ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::Timespec>>(
                    PrepareAsyncGetTimeRaw(context, request, cq));
        }

        class async_interface {
        public:
            virtual ~async_interface() {}

            virtual void GetTime(::grpc::ClientContext *context, const ::GetTimeRequest *request, ::Timespec *response,
                                 std::function<void(::grpc::Status)>) = 0;

            virtual void GetTime(::grpc::ClientContext *context, const ::GetTimeRequest *request, ::Timespec *response,
                                 ::grpc::ClientUnaryReactor *reactor) = 0;
        };

        typedef class async_interface experimental_async_interface;

        virtual class async_interface *async() { return nullptr; }

        class async_interface *experimental_async() { return async(); }

    private:
        virtual ::grpc::ClientAsyncResponseReaderInterface<::Timespec> *
        AsyncGetTimeRaw(::grpc::ClientContext *context, const ::GetTimeRequest &request,
                        ::grpc::CompletionQueue *cq) = 0;

        virtual ::grpc::ClientAsyncResponseReaderInterface<::Timespec> *
        PrepareAsyncGetTimeRaw(::grpc::ClientContext *context, const ::GetTimeRequest &request,
                               ::grpc::CompletionQueue *cq) = 0;
    };

    class Stub final : public StubInterface {
    public:
        Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
             const ::grpc::StubOptions &options = ::grpc::StubOptions());

        ::grpc::Status
        GetTime(::grpc::ClientContext *context, const ::GetTimeRequest &request, ::Timespec *response) override;

        std::unique_ptr<::grpc::ClientAsyncResponseReader<::Timespec>>
        AsyncGetTime(::grpc::ClientContext *context, const ::GetTimeRequest &request, ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::Timespec>>(
                    AsyncGetTimeRaw(context, request, cq));
        }

        std::unique_ptr<::grpc::ClientAsyncResponseReader<::Timespec>>
        PrepareAsyncGetTime(::grpc::ClientContext *context, const ::GetTimeRequest &request,
                            ::grpc::CompletionQueue *cq) {
            return std::unique_ptr<::grpc::ClientAsyncResponseReader<::Timespec>>(
                    PrepareAsyncGetTimeRaw(context, request, cq));
        }

        class async final :
                public StubInterface::async_interface {
        public:
            void GetTime(::grpc::ClientContext *context, const ::GetTimeRequest *request, ::Timespec *response,
                         std::function<void(::grpc::Status)>) override;

            void GetTime(::grpc::ClientContext *context, const ::GetTimeRequest *request, ::Timespec *response,
                         ::grpc::ClientUnaryReactor *reactor) override;

        private:
            friend class Stub;

            explicit async(Stub *stub) : stub_(stub) {}

            Stub *stub() { return stub_; }

            Stub *stub_;
        };

        class async *async() override { return &async_stub_; }

    private:
        std::shared_ptr<::grpc::ChannelInterface> channel_;

        class async async_stub_{this};

        ::grpc::ClientAsyncResponseReader<::Timespec> *
        AsyncGetTimeRaw(::grpc::ClientContext *context, const ::GetTimeRequest &request,
                        ::grpc::CompletionQueue *cq) override;

        ::grpc::ClientAsyncResponseReader<::Timespec> *
        PrepareAsyncGetTimeRaw(::grpc::ClientContext *context, const ::GetTimeRequest &request,
                               ::grpc::CompletionQueue *cq) override;

        const ::grpc::internal::RpcMethod rpcmethod_GetTime_;
    };

    static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
                                         const ::grpc::StubOptions &options = ::grpc::StubOptions());

    class Service : public ::grpc::Service {
    public:
        Service();

        virtual ~Service();

        virtual ::grpc::Status
        GetTime(::grpc::ServerContext *context, const ::GetTimeRequest *request, ::Timespec *response);
    };

    template<class BaseClass>
    class WithAsyncMethod_GetTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

    public:
        WithAsyncMethod_GetTime() {
            ::grpc::Service::MarkMethodAsync(0);
        }

        ~WithAsyncMethod_GetTime() override {
            BaseClassMustBeDerivedFromService(this);
        }

        // disable synchronous version of this method
        ::grpc::Status GetTime(::grpc::ServerContext * /*context*/, const ::GetTimeRequest * /*request*/,
                               ::Timespec * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }

        void RequestGetTime(::grpc::ServerContext *context, ::GetTimeRequest *request,
                            ::grpc::ServerAsyncResponseWriter<::Timespec> *response,
                            ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                            void *tag) {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };

    typedef WithAsyncMethod_GetTime<Service> AsyncService;

    template<class BaseClass>
    class WithCallbackMethod_GetTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

    public:
        WithCallbackMethod_GetTime() {
            ::grpc::Service::MarkMethodCallback(0,
                                                new ::grpc::internal::CallbackUnaryHandler<::GetTimeRequest, ::Timespec>(
                                                        [this](
                                                                ::grpc::CallbackServerContext *context,
                                                                const ::GetTimeRequest *request, ::Timespec *response) {
                                                            return this->GetTime(context, request, response);
                                                        }));
        }

        void SetMessageAllocatorFor_GetTime(
                ::grpc::MessageAllocator<::GetTimeRequest, ::Timespec> *allocator) {
            ::grpc::internal::MethodHandler *const handler = ::grpc::Service::GetHandler(0);
            static_cast<::grpc::internal::CallbackUnaryHandler<::GetTimeRequest, ::Timespec> *>(handler)
                    ->SetMessageAllocator(allocator);
        }

        ~WithCallbackMethod_GetTime() override {
            BaseClassMustBeDerivedFromService(this);
        }

        // disable synchronous version of this method
        ::grpc::Status GetTime(::grpc::ServerContext * /*context*/, const ::GetTimeRequest * /*request*/,
                               ::Timespec * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }

        virtual ::grpc::ServerUnaryReactor *GetTime(
                ::grpc::CallbackServerContext * /*context*/, const ::GetTimeRequest * /*request*/,
                ::Timespec * /*response*/) { return nullptr; }
    };

    typedef WithCallbackMethod_GetTime<Service> CallbackService;
    typedef CallbackService ExperimentalCallbackService;

    template<class BaseClass>
    class WithGenericMethod_GetTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

    public:
        WithGenericMethod_GetTime() {
            ::grpc::Service::MarkMethodGeneric(0);
        }

        ~WithGenericMethod_GetTime() override {
            BaseClassMustBeDerivedFromService(this);
        }

        // disable synchronous version of this method
        ::grpc::Status GetTime(::grpc::ServerContext * /*context*/, const ::GetTimeRequest * /*request*/,
                               ::Timespec * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }
    };

    template<class BaseClass>
    class WithRawMethod_GetTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

    public:
        WithRawMethod_GetTime() {
            ::grpc::Service::MarkMethodRaw(0);
        }

        ~WithRawMethod_GetTime() override {
            BaseClassMustBeDerivedFromService(this);
        }

        // disable synchronous version of this method
        ::grpc::Status GetTime(::grpc::ServerContext * /*context*/, const ::GetTimeRequest * /*request*/,
                               ::Timespec * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }

        void RequestGetTime(::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
                            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
                            ::grpc::CompletionQueue *new_call_cq, ::grpc::ServerCompletionQueue *notification_cq,
                            void *tag) {
            ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
        }
    };

    template<class BaseClass>
    class WithRawCallbackMethod_GetTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

    public:
        WithRawCallbackMethod_GetTime() {
            ::grpc::Service::MarkMethodRawCallback(0,
                                                   new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                                                           [this](
                                                                   ::grpc::CallbackServerContext *context,
                                                                   const ::grpc::ByteBuffer *request,
                                                                   ::grpc::ByteBuffer *response) {
                                                               return this->GetTime(context, request, response);
                                                           }));
        }

        ~WithRawCallbackMethod_GetTime() override {
            BaseClassMustBeDerivedFromService(this);
        }

        // disable synchronous version of this method
        ::grpc::Status GetTime(::grpc::ServerContext * /*context*/, const ::GetTimeRequest * /*request*/,
                               ::Timespec * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }

        virtual ::grpc::ServerUnaryReactor *GetTime(
                ::grpc::CallbackServerContext * /*context*/, const ::grpc::ByteBuffer * /*request*/,
                ::grpc::ByteBuffer * /*response*/) { return nullptr; }
    };

    template<class BaseClass>
    class WithStreamedUnaryMethod_GetTime : public BaseClass {
    private:
        void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

    public:
        WithStreamedUnaryMethod_GetTime() {
            ::grpc::Service::MarkMethodStreamed(0,
                                                new ::grpc::internal::StreamedUnaryHandler<
                                                        ::GetTimeRequest, ::Timespec>(
                                                        [this](::grpc::ServerContext *context,
                                                               ::grpc::ServerUnaryStreamer<
                                                                       ::GetTimeRequest, ::Timespec> *streamer) {
                                                            return this->StreamedGetTime(context,
                                                                                         streamer);
                                                        }));
        }

        ~WithStreamedUnaryMethod_GetTime() override {
            BaseClassMustBeDerivedFromService(this);
        }

        // disable regular version of this method
        ::grpc::Status GetTime(::grpc::ServerContext * /*context*/, const ::GetTimeRequest * /*request*/,
                               ::Timespec * /*response*/) override {
            abort();
            return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
        }

        // replace default version of method with streamed unary
        virtual ::grpc::Status StreamedGetTime(::grpc::ServerContext *context,
                                               ::grpc::ServerUnaryStreamer<::GetTimeRequest, ::Timespec> *server_unary_streamer) = 0;
    };

    typedef WithStreamedUnaryMethod_GetTime<Service> StreamedUnaryService;
    typedef Service SplitStreamedService;
    typedef WithStreamedUnaryMethod_GetTime<Service> StreamedService;
};


#endif  // GRPC_time_5fserver_2eproto__INCLUDED
